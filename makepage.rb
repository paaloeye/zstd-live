#!/usr/bin/env ruby

fpath = ARGV[0]
fname_rel = ARGV[1]

# make relative link for root of "site" and shared CSS
root_rel_link = '../' * fname_rel.count('/')

puts <<HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>#{fname_rel} - Zig standard library</title>
    <link rel="stylesheet" href="#{root_rel_link}styles.css">
</head>
<body>
</header>

<table><tbody>
<tr><td class="doc">
<h1>
  <a href="#{root_rel_link}std.zig.html">std</a> /
  #{fname_rel}
</h1>
HTML

# Print a greeting on the entry file. Greeting gets its own row.
if fname_rel == 'std.zig'
  puts <<HTML
<p>What you're looking at is a file called <code>std.zig</code>. It's the entry
point of the Zig Standard library, which imports and gives names to the rest of
the library.</p>
<p>Everything in the right column is the Zig source code in the file. And what you
see in this left column (hello!) will be public identifiers and any document comments.</p>
<p>There aren't a lot of comments in <em>this</em> file yet, but there are a
lot of links you can click on. If you're not sure where to start, try the
<code>array_list.zig</code> link under the name "ArrayList". That one has some
comments. Some other files I tend to look at a lot are <code>fmt.zig</code>
and <code>mem.zig</code></p>
</td><td class="code"></td></tr><tr><td class="doc">
HTML
end

# used to collect documentation comments, line-by-line
doc_comment = nil

# we always start the page in the documentation column
in_code_block = false

def new_chunk(extra_class='')
      puts '</td></tr>'
      puts "<tr><td class=\"doc #{extra_class}\">"
end

File.read(fpath).each_line do |line|
  # Doc comment (/// or //!), we must gather it!
  if line.match?(/^\/{2}[!\/]/)
    comment = line[3..-1]

    if comment.match?(/^\s*$/)
      comment = "<br><br>"
    end

    if doc_comment
      doc_comment += comment
    else
      doc_comment = comment
    end

    next
  end

  # When we encounter a special document thing, we'll store it here.
  my_special_thing = nil

  # This is will just be used as a CSS class name for formatting. Blank
  # means default formatting.
  my_chunk_type = ""

  # Detect Special Documentation Stuff and Print 'Em!
  # --------------------------------------------------------------------------

  # pub const
  if name = line.match(/^pub const (\w+)/)
    my_chunk_type = 'value'

    my_special_thing = "<h2>#{name[1]}</h2>"

    if fname = line.match(/@import\("(.*zig)"\)/)
      my_special_thing += "<a href=\"#{fname[1]}.html\">#{fname[1]}</a>"
    end
  end

  # pub fn
  if name = line.match(/^pub( inline)? fn (\w+)/)
    my_special_thing = "<h2>#{name[2]}()</h2>"
  end

  # struct/enum method pub fn
  if name = line.match(/^\s+pub( inline)? fn (\w+)/)
    my_chunk_type = 'method'
    my_special_thing = "<h2>#{name[2]}</h2>"
  end

  # Print any non-comment thing detected above
  if my_special_thing
    if in_code_block
      puts '</td></tr>'
      puts "<tr><td class=\"doc #{my_chunk_type}\">"
    end

    puts my_special_thing

    if doc_comment
      puts "<p>#{doc_comment}</p>"
      doc_comment = nil
    end

    in_code_block = false
  end

  # Everything Else is Code!
  # --------------------------------------------------------------------------
  if !in_code_block
    in_code_block = true

    if doc_comment
      puts "<p>#{doc_comment}</p>"
      doc_comment = nil
    end

    puts '</td>' #end the doc cell
    puts '<td class="code">'
  end

  # the actual line of source!
  puts line
end

puts <<HTML
</td></tr>
<tr><td class="doc" id="footer">
  Generated by <a href="http://ratfactor.com/repos/zstd-browse2/">zstd-browse2</a>
  on #{Time.now}.
</td><td class="code"></td></tr>
</tbody></table>
</body>
</html>
HTML
