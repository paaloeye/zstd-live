#!/usr/bin/env ruby

fpath = ARGV[0]
fname_rel = ARGV[1]

# make relative link for root of "site" and shared CSS
root_rel_link = '../' * fname_rel.count('/')

puts <<HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>#{fname_rel} - Zig standard library</title>
    <link rel="stylesheet" href="#{root_rel_link}styles.css">
</head>
<body>
<table><tbody>
<tr><td class="doc">
<h1>
  <a href="index.html"><img src="#{root_rel_link}zig-stdlib-book.svg" alt="" width="60"> zig/lib/std</a> /
  #{fname_rel}
</h1>
HTML

# used to collect documentation comments, line-by-line
doc_comment = nil

# we always start the page in the documentation column
in_code_block = false

def new_chunk(extra_class='')
  puts '</pre></td></tr>' # end code block
  puts "<tr><td class=\"doc #{extra_class}\">"
end

File.read(fpath).each_line do |line|
  # Doc comment (/// or //!), we must gather it!
  if comment = line.match(/^\s*\/{2}[!\/](.*)$/)
    comment = comment[1]
    if comment.match?(/^\s*$/)
      comment = "<br><br>"
    end

    # replace all `foo` with <code>foo</code>
    comment.gsub!(/`([^`]+)`/, '<code>\1</code>')

    if doc_comment
      doc_comment += comment
    else
      doc_comment = comment
    end

    next
  end

  # When we encounter a special document thing, we'll store it here.
  my_special_thing = nil

  # This is will just be used as a CSS class name for formatting. Blank
  # means default formatting.
  my_chunk_type = ""

  # Detect Special Documentation Stuff and Print 'Em!
  # --------------------------------------------------------------------------

  # pub const
  if name = line.match(/^pub const (\w+)/)
    my_chunk_type = 'value'

    my_special_thing = "<h2>#{name[1]}</h2>"

    if fname = line.match(/@import\("(.*zig)"\)/)
      my_special_thing += "<a href=\"#{fname[1]}.html\">#{fname[1]}</a>"
    end
  end

  # pub fn
  if name = line.match(/^pub( inline)? fn (\w+)/)
    my_special_thing = "<h2>#{name[2]}()</h2>"
  end

  # struct/enum method pub fn
  if name = line.match(/^\s+pub( inline)? fn (\w+)/)
    my_chunk_type = 'method'
    my_special_thing = "<h2>#{name[2]}()</h2>"
  end

  # test with "string" description
  if name = line.match(/^\s*test "(.*)" {$/)
    my_chunk_type = 'test-str'
    my_special_thing = "<h2>Test:</h2><h3>#{name[1]}</h3>"
  end

  # test with Decl description
  if name = line.match(/^\s*test (\w+) {$/)
    my_chunk_type = 'test-decl'
    my_special_thing = "<h2>Test: #{name[1]}</h2>"
  end

  # Print any non-comment thing detected above
  if my_special_thing
    if in_code_block
      puts '</pre></td></tr>' # end code block
      puts "<tr><td class=\"doc #{my_chunk_type}\">"
    end

    puts my_special_thing

    if doc_comment
      puts "<p>#{doc_comment}</p>"
      doc_comment = nil
    end

    in_code_block = false
  end

  # Everything Else is Code!
  # --------------------------------------------------------------------------
  if !in_code_block
    in_code_block = true

    if doc_comment
      puts "<p>#{doc_comment}</p>"
      doc_comment = nil
    end

    puts '</td>' #end the doc cell
    puts '<td class="code"><pre>'
  end

  # the actual line of source!
  puts line
end

# end final code block and footer it up!
puts <<HTML
</pre></td></tr>
<tr><td class="doc" id="footer">
  Generated by <a href="http://ratfactor.com/repos/zstd-browse2/">zstd-browse2</a>
  on #{Time.now}.
</td><td class="code"></td></tr>
</tbody></table>
</body>
</html>
HTML
